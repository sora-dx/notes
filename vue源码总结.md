# 总结

## 响应式原理

1. 数据代理：遍历 data 原数据所有属性，对每一个属性进行数据代理，可以通过 this 直接访问，
   数据代理通过 Object.defineProperty 将属性定义在 this 上，同时定义属性 get/set...
   当你通过 this 读取属性时，实际读取是 data 原数据属性的值
   当你通过 this 设置属性时，实际设置是 data 原数据属性的值
   
2. 数据劫持：将 data 原数据中所有属性进行重新定义，定义成响应式
   提取 data 中所有属性进行遍历, 所有属性一个一个进行 Object.defineProperty 重新定义
   定义成响应式。
   每一个响应式属性都有一个自己的 dep 对象，通过闭包的方式保存再 get/set 方法中

3. 模板解析：解析模板页面中插值语法和指令语法

```
将el的所有子元素添加到文档碎片节点
    创建文档碎片节点
    遍历el所有子元素，添加到文档碎片节点中
    返回文档碎片节点
解析文档碎片节点中模板语法
  遍历所有子节点，判断子节点是元素节点还是文本节点
    如果是元素节点，要解析里面的指令语法
      提取节点所有属性节点，遍历，判断是否是指令语法(v-)
      再判断是事件指令(on)还是普通指令
        事件指令：给当前节点绑定事件和相应的回调函数，回调函数通过bind方法改变this指向为vm
        普通指令：调用相应的更新DOM元素的updater方法更新DOM的值
          比如：v-text, 调用textUpdater，更新元素textContent属性
          比如：v-html, 调用htmlUpdater，更新元素innerHTML属性
          最后，new Watcher
      删除解析后的指令属性
    如果是文本节点，要解析里面的插值语法
      解析方式最终和v-text是一致的，调用textUpdater，更新元素textContent属性
  递归编译当前子节点所有子节点，为了让所有节点都要被解析
将解析好文档碎片节点添加到el，生效
```

4. new Watcher
   读取表达式，此时触发数据劫持阶段设置属性设置的 get 方法
   通过 dep.depend()建立起响应式联系：dep 中保存 watcher，watcher 保存 dep
   所有响应式数据属性都有自己的 dep，所有模板语法（没有事件指令）都有 watcher

5. 触发响应式
   更新响应式数据的值
   触发数据代理的 set 方法，里面更新 data 原数据
   触发数据劫持的 set 方法，里面更新值，也会将新值变成响应式，调用 dep.notify()
   通过当前 dep 保存的所有 watcher 去调用 cb，更新用户界面，从而达到响应式
   响应式: 更新数据时，数据变，用户界面也变

## v-model / 双向数据绑定原理

给 input 绑定 value 属性，值为表达式的值
给 input 绑定 input 事件，收集用户输入的数据，更新 data 原数据属性的值，触发响应式流程~
